#!/usr/bin/env sh
# Expand and Put: like Put except that tabs are expanded to four spaces.
# Acme does not support expanding tabs to spaces, but when working on projects
# which uses spaces for indentation, indenting with the spacebar is tedious
# (even with Indent on).  The idea behind this script is that when editing such
# code, you can freely hit Tab to indent, and then you save with Eput (which
# must be added to the tag) rather than Put, which will convert all the tabs
# you inserted to spaces.
#
# This script has some quirks:
# - If Eput finds tabs to expand, it adds two records to the Undo log.
# - If Eput finds tabs to expand, it clobbers dot: specifically, dot is changed
#   to be the entire first line of where dot started before.
# - If Eput does not find tabs to expand, it is equivalent to Put, and
#   neither of the above happens.

if [ "$winid" = "" ]; then
	echo "$0: must be run within Acme" 2>&1
	exit 1
fi

aread() {
	9p read acme/$winid/$1
}
awrite() {
	9p write acme/$winid/$1
}

# create temporary files which are deleted on exit
tmpold=$(mktemp)
trap 'rm -f -- "$tmpold"' EXIT
tmpnew=$(mktemp)
trap 'rm -f -- "$tmpnew"' EXIT

# dump body into a file and then another file with tabs expanded
aread body >"$tmpold"
expand -t4 <"$tmpold" >"$tmpnew"

# if there were no tabs to be expanded, skip updating the body
if ! cmp "$tmpold" "$tmpnew" 2>&1 >/dev/null; then
	# note: deliberately not using nomark here, it doesn't seem to work
	# correctly, it just makes the Undo history messier

	# Updating the entire body will cause the Acme window to jump to the
	# end-of-file.  We want to save the original position of dot (i.e.,
	# the highlighted selection) and restore it, so that executing Eput
	# does not result in losing your place.  Unfortunately, there does
	# not seem to be a direct method of reading where dot is (reading from
	# addr after writing 'addr=dot' to ctl does not work).  So, save the
	# position of dot in a klugey and crude way: replace dot with a special
	# pattern (it doesn't matter that this corrupts the file, since it's
	# about to be replaced wholesale) and save the line number where the
	# pattern appears.
	echo 'addr=dot' | awrite ctl
	echo -n '___Eput_dotsave___' | awrite data
	linum=$(aread body | grep -n ___Eput_dotsave___ | awk -F':' '{ print $1 }')

	# replace original body with tab-expanded body
	echo -n , | awrite addr
	awrite data <"$tmpnew"

	# return to saved dot location
	echo -n $linum | awrite addr
	echo 'dot=addr' | awrite ctl
	echo show | awrite ctl
fi

# finally, Put
echo -n put | awrite ctl
